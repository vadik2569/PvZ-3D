<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PvZ 3D - Rebuilt</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: #222;
            font-family: 'Rubik', sans-serif;
        }

        /* UI LAYER - Strictly non-blocking */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* INTERACTIVE ELEMENTS - Explicitly allow clicks */
        .interactive {
            pointer-events: auto;
        }

        /* HUD */
        .hud-top {
            padding: 20px;
            display: flex;
            gap: 20px;
        }

        .resource-badge {
            background: rgba(0, 0, 0, 0.7);
            color: #ffd700;
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 24px;
            font-weight: bold;
            border: 2px solid #555;
        }

        /* PLANT SELECTOR */
        .plant-bar {
            align-self: center;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 20px;
            display: flex;
            gap: 10px;
            backdrop-filter: blur(5px);
        }

        .plant-card {
            width: 80px;
            height: 100px;
            background: #444;
            border: 2px solid #666;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            transition: all 0.2s;
        }

        .plant-card:hover {
            transform: translateY(-5px);
            border-color: white;
        }

        .plant-card.selected {
            border-color: #4caf50;
            background: #2e3b2f;
            box-shadow: 0 0 15px #4caf50;
        }

        .cost {
            font-size: 14px;
            color: #ffd700;
            margin-top: 5px;
        }

        /* MENUS */
        .center-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #333;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 4px solid #4caf50;
            box-shadow: 0 0 50px black;
        }

        button {
            background: #4caf50;
            border: none;
            padding: 15px 30px;
            color: white;
            font-size: 20px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
        }

        button:hover {
            background: #66bb6a;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>

    <!-- 3D CANVAS -->
    <canvas id="game-canvas"></canvas>

    <!-- UI OVERLAY -->
    <div id="ui-layer">

        <!-- TOP HUD -->
        <div class="hud-top">
            <div class="resource-badge">‚òÄÔ∏è <span id="sun-display">150</span></div>
            <div class="resource-badge">üß† <span id="score-display">0</span></div>
            <div id="player-list-hud"
                style="background:rgba(0,0,0,0.5); padding:10px; border-radius:10px; color:white; min-width: 100px;">
                <b style="color:#4caf50;">Players:</b>
                <ul id="players-ul" style="padding-left: 20px; margin: 5px 0 0 0; list-style: none;"></ul>
            </div>
            <div id="debug-msg" style="color:red; background:black; padding:5px; height: fit-content;">State: Init</div>
        </div>

        <!-- CENTER MENUS -->
        <div id="start-menu" class="center-menu interactive">
            <h1 style="color:#4caf50; font-size: 50px; margin:0;">PvZ 3D</h1>
            <p style="color:#ccc;">Rebuilt for Stability</p>
            <input type="text" id="nickname" placeholder="Your Nickname" value="Player 1"
                style="padding:10px; margin-bottom: 20px; display:block; width: 80%; margin-left: auto; margin-right: auto;">

            <button onclick="startGame(true)">START GAME (HOST)</button>
            <br><br>
            <input type="text" id="host-id" placeholder="Host ID to Join" style="padding:10px;">
            <button onclick="startGame(false)" style="background:#444; font-size:16px;">Join Game</button>
        </div>

        <!-- PLANT BAR -->
        <div id="game-controls" class="plant-bar interactive hidden">
            <!-- Left side: Player List -->
            <div id="player-list-hud" style="color: white; font-size: 12px; margin-right: 20px; text-align: left;">
                Players:
                <ul id="players-ul" style="padding-left: 15px; margin: 0;"></ul>
            </div>

            <div class="plant-card selected" onclick="selectPlant('peashooter')">
                <span>Pea</span>
                <span class="cost">100</span>
            </div>
            <div class="plant-card" onclick="selectPlant('sunflower')">
                <span>Sun</span>
                <span class="cost">50</span>
            </div>
            <div class="plant-card" onclick="selectPlant('wallnut')">
                <span>Nut</span>
                <span class="cost">50</span>
            </div>
        </div>

    </div>

    <!-- LIBRARIES -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script>
        // --- GLOBAL STATE ---
        const CONFIG = {
            GRID_W: 9,
            GRID_H: 5,
            TILE_SIZE: 10
        };

        let state = {
            sun: 150,
            score: 0,
            plants: [],
            zombies: [],
            projectiles: [],
            suns: [],
            active: false,
            isHost: true,
            players: []
        };

        const objects = {
            meshMap: new Map(), // ID -> Mesh
            tiles: [] // Array of meshes
        };

        let activeTool = 'peashooter';
        let myName = "Player";
        let peer, conn;
        let connections = [];

        // --- GRAPHICS GENERATORS ---
        function createPeashooter() {
            const g = new THREE.Group();

            // Stem
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 3), new THREE.MeshStandardMaterial({ color: 0x2e7d32 }));
            stem.position.y = 1.5;

            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshStandardMaterial({ color: 0x4caf50 }));
            head.position.y = 3.5;

            // Snout
            const snout = new THREE.Mesh(new THREE.CylinderGeometry(1, 0.8, 1.5), new THREE.MeshStandardMaterial({ color: 0x4caf50 }));
            snout.position.set(0, 3.5, 1);
            snout.rotation.x = Math.PI / 2;

            // Leaves
            const leafGeo = new THREE.ConeGeometry(0.8, 2, 4);
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
            for (let i = 0; i < 4; i++) {
                const l = new THREE.Mesh(leafGeo, leafMat);
                l.position.y = 0.5;
                l.rotation.y = (Math.PI / 2) * i;
                l.rotation.z = Math.PI / 3;
                l.translateX(0.5);
                g.add(l);
            }

            g.add(stem, head, snout);
            return g;
        }

        function createSunflower() {
            const g = new THREE.Group();
            // Stem
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 3), new THREE.MeshStandardMaterial({ color: 0x2e7d32 }));
            stem.position.y = 1.5;

            // Face
            const face = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 0.5), new THREE.MeshStandardMaterial({ color: 0x3e2723 }));
            face.position.set(0, 3.5, 0.1);
            face.rotation.x = Math.PI / 2;

            // Petals
            const petals = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 0.2), new THREE.MeshStandardMaterial({ color: 0xffeb3b }));
            petals.position.set(0, 3.5, -0.1);
            petals.rotation.x = Math.PI / 2;

            g.add(stem, face, petals);
            return g;
        }

        function createWallnut() {
            const g = new THREE.Mesh(new THREE.SphereGeometry(1.8), new THREE.MeshStandardMaterial({ color: 0x8d6e63 }));
            g.scale.set(1, 1.4, 1);
            g.position.y = 2.5;
            return g;
        }

        function createZombie() {
            const g = new THREE.Group();

            // Legs
            const lLeg = new THREE.Mesh(new THREE.BoxGeometry(1, 3, 1), new THREE.MeshStandardMaterial({ color: 0x37474f }));
            lLeg.position.set(-0.6, 1.5, 0);
            const rLeg = new THREE.Mesh(new THREE.BoxGeometry(1, 3, 1), new THREE.MeshStandardMaterial({ color: 0x37474f }));
            rLeg.position.set(0.6, 1.5, 0);

            // Torso
            const torso = new THREE.Mesh(new THREE.BoxGeometry(2.4, 3, 1.2), new THREE.MeshStandardMaterial({ color: 0x5d4037 }));
            torso.position.set(0, 4.5, 0);

            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.8, 1.8), new THREE.MeshStandardMaterial({ color: 0x7cb342 }));
            head.position.set(0, 7, 0);

            // Arms
            const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.8, 2.5, 0.8), new THREE.MeshStandardMaterial({ color: 0x5d4037 }));
            lArm.position.set(-1.4, 5.5, 1);
            lArm.rotation.x = -Math.PI / 2; // Point forward

            const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.8, 2.5, 0.8), new THREE.MeshStandardMaterial({ color: 0x5d4037 }));
            rArm.position.set(1.4, 5.5, 1);
            rArm.rotation.x = -Math.PI / 2;

            g.add(lLeg, rLeg, torso, head, lArm, rArm);
            return g;
        }

        // --- SCENE INIT ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 60, 50);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        // Lights
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(20, 50, 20);
        light.castShadow = true;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));

        // Selector / Ghost
        const selector = new THREE.Mesh(
            new THREE.BoxGeometry(CONFIG.TILE_SIZE, 0.5, CONFIG.TILE_SIZE),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 })
        );
        scene.add(selector);

        // --- GRID GENERATION ---
        // We create a single mesh for the ground? No, individual tiles for clicking is easier for logic
        const tileGeo = new THREE.BoxGeometry(CONFIG.TILE_SIZE - 0.5, 1, CONFIG.TILE_SIZE - 0.5);
        const matLight = new THREE.MeshStandardMaterial({ color: 0x81C784 });
        const matDark = new THREE.MeshStandardMaterial({ color: 0x66BB6A });

        for (let x = 0; x < CONFIG.GRID_W; x++) {
            for (let z = 0; z < CONFIG.GRID_H; z++) {
                const isDark = (x + z) % 2 === 0;
                const tile = new THREE.Mesh(tileGeo, isDark ? matDark : matLight);

                // Position: Center grid at 0,0
                const px = (x - CONFIG.GRID_W / 2 + 0.5) * CONFIG.TILE_SIZE;
                const pz = (z - CONFIG.GRID_H / 2 + 0.5) * CONFIG.TILE_SIZE;

                tile.position.set(px, -0.5, pz);
                tile.userData = { isTile: true, gx: x, gz: z };
                tile.receiveShadow = true;

                scene.add(tile);
                objects.tiles.push(tile);
            }
        }

        // --- GAME LOGIC ---

        function startGame(asHost) {
            state.active = true;
            state.isHost = asHost;
            myName = document.getElementById('nickname').value || "Player";

            document.getElementById('start-menu').classList.add('hidden');
            document.getElementById('game-controls').classList.remove('hidden');
            document.getElementById('debug-msg').innerText = "Game Active";

            if (asHost) {
                state.players.push({ name: myName, id: 'HOST' });
                peer = new Peer();
                peer.on('open', id => console.log('Host ID:', id));
                peer.on('connection', c => {
                    connections.push(c);
                    c.on('data', d => handlePacket(c, d));
                });
                requestAnimationFrame(gameLoop);
            } else {
                const id = document.getElementById('host-id').value;
                peer = new Peer();
                conn = peer.connect(id);
                conn.on('open', () => {
                    conn.send({ type: 'JOIN', name: myName });
                });
                conn.on('data', d => handlePacket(null, d));
                requestAnimationFrame(renderLoop);
            }
        }

        function handlePacket(sender, d) {
            if (state.isHost) {
                // Host Logic
                if (d.type === 'REQ_PLACE') attemptPlace(d.typeStr, d.gx, d.gz);
                else if (d.type === 'REQ_SUN') collectSun(d.id);
                else if (d.type === 'JOIN') {
                    state.players.push({ name: d.name, id: sender.peer });
                    updateHUD();
                    broadcastState();
                }
            } else {
                // Client Logic
                if (d.type === 'STATE') syncState(d.data);
            }
        }

        function syncState(serverState) {
            state = serverState;
            updateHUD();
        }

        // --- CORE INTERACTION ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousemove', e => {
            const canvas = document.getElementById('game-canvas');
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            if (!state.active) return;

            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(objects.tiles);

            if (hits.length > 0) {
                const tile = hits[0].object;
                selector.visible = true;
                selector.position.copy(tile.position);
                selector.position.y = 1; // Hover above

                // Color ghost based on validity
                const occ = state.plants.find(p => p.gx === tile.userData.gx && p.gz === tile.userData.gz);
                selector.material.color.setHex(occ ? 0xff0000 : 0x00ff00);
            } else {
                selector.visible = false;
            }
        });

        window.addEventListener('click', e => {
            if (e.target.closest('.interactive')) return; // Ignore UI clicks
            if (!state.active) return;

            raycaster.setFromCamera(mouse, camera);

            // 1. CLICK SUN
            // Find sun meshes
            const sunMeshes = [];
            scene.traverse(o => { if (o.userData.type === 'SUN') sunMeshes.push(o); });
            const sunHits = raycaster.intersectObjects(sunMeshes);

            if (sunHits.length > 0) {
                const sunId = sunHits[0].object.userData.id;
                if (state.isHost) collectSun(sunId);
                else conn.send({ type: 'REQ_SUN', id: sunId });
                return;
            }

            // 2. CLICK TILE (PLACE PLANT)
            const tileHits = raycaster.intersectObjects(objects.tiles);
            if (tileHits.length > 0) {
                const { gx, gz } = tileHits[0].object.userData;
                if (state.isHost) attemptPlace(activeTool, gx, gz);
                else conn.send({ type: 'REQ_PLACE', typeStr: activeTool, gx, gz });
            }
        });

        // --- HOST ACTIONS ---
        function attemptPlace(type, gx, gz) {
            // Validate Logic
            const cost = { 'peashooter': 100, 'sunflower': 50, 'wallnut': 50 }[type];
            if (state.sun < cost) {
                console.log("Not enough sun");
                return; // Fail
            }
            if (state.plants.find(p => p.gx === gx && p.gz === gz)) {
                console.log("Occupied");
                return; // Fail
            }

            // Success
            state.sun -= cost;
            state.plants.push({
                id: Math.random().toString(36),
                type, gx, gz,
                hp: 100,
                lastAction: 0
            });
            updateHUD();
            broadcastState();
        }

        function collectSun(id) {
            const s = state.suns.find(x => x.id === id);
            if (s) {
                state.suns = state.suns.filter(x => x !== s);
                state.sun += 25;
                updateHUD();
                broadcastState();
            }
        }

        function broadcastState() {
            const d = {
                type: 'STATE',
                data: {
                    plants: state.plants,
                    zombies: state.zombies,
                    suns: state.suns,
                    sun: state.sun,
                    score: state.score
                }
            };
            connections.forEach(c => c.send(d));
        }

        // --- VISUALS ---
        function updateHUD() {
            document.getElementById('sun-display').innerText = Math.floor(state.sun);
            document.getElementById('score-display').innerText = state.score;

            // Update Player List
            const ul = document.getElementById('players-ul');
            if (state.players) {
                ul.innerHTML = state.players.map(p => `<li>üë§ ${p.name}</li>`).join('');
            }
        }

        window.selectPlant = (t) => {
            activeTool = t;
            document.querySelectorAll('.plant-card').forEach(e => e.classList.remove('selected'));
            // Find specific card (lazy select)
            if (t === 'peashooter') document.querySelectorAll('.plant-card')[0].classList.add('selected');
            if (t === 'sunflower') document.querySelectorAll('.plant-card')[1].classList.add('selected');
            if (t === 'wallnut') document.querySelectorAll('.plant-card')[2].classList.add('selected');
        }

        // --- LOOPS ---

        let lastTime = 0;
        let spawnTimer = 0;
        let sunTimer = 0;

        function gameLoop(time) {
            requestAnimationFrame(gameLoop);
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            // Host Game Logic
            spawnTimer += dt;
            if (spawnTimer > 4) {
                state.zombies.push({
                    id: Math.random().toString(),
                    x: 50, // Right side
                    z: (Math.floor(Math.random() * CONFIG.GRID_H) - CONFIG.GRID_H / 2 + 0.5) * CONFIG.TILE_SIZE,
                    hp: 100
                });
                spawnTimer = 0;
            }

            sunTimer += dt;
            if (sunTimer > 5) {
                state.suns.push({
                    id: Math.random().toString(),
                    x: (Math.random() - 0.5) * 80,
                    y: 40,
                    z: (Math.random() - 0.5) * 40
                });
                sunTimer = 0;
            }

            // --- INTERACTION LOGIC ---

            // 1. PLANTS
            state.plants.forEach(p => {
                if (time - p.lastAction < 1500) return; // Cooldown

                if (p.type === 'peashooter') {
                    // Check lane
                    const pz = (p.gz - CONFIG.GRID_H / 2 + 0.5) * CONFIG.TILE_SIZE;
                    const px = (p.gx - CONFIG.GRID_W / 2 + 0.5) * CONFIG.TILE_SIZE;

                    const hasTarget = state.zombies.some(z => Math.abs(z.z - pz) < 1 && z.x > px);
                    if (hasTarget) {
                        state.projectiles.push({
                            id: Math.random().toString(),
                            x: px, z: pz,
                            vx: 30
                        });
                        p.lastAction = time;
                    }
                } else if (p.type === 'sunflower') {
                    if (time - p.lastAction > 5000) { // 5s for sunflower
                        state.suns.push({
                            id: Math.random().toString(),
                            x: (p.gx - CONFIG.GRID_W / 2 + 0.5) * CONFIG.TILE_SIZE,
                            y: 5,
                            z: (p.gz - CONFIG.GRID_H / 2 + 0.5) * CONFIG.TILE_SIZE
                        });
                        p.lastAction = time;
                    }
                }
            });

            // 2. ZOMBIES
            state.zombies.forEach(z => {
                // Check eat
                const myLaneParams = state.plants.filter(p => {
                    const pz = (p.gz - CONFIG.GRID_H / 2 + 0.5) * CONFIG.TILE_SIZE;
                    return Math.abs(pz - z.z) < 1;
                });

                const target = myLaneParams.find(p => {
                    const px = (p.gx - CONFIG.GRID_W / 2 + 0.5) * CONFIG.TILE_SIZE;
                    return Math.abs(z.x - px) < 4 && z.x > px; // Close and to the right
                });

                if (target) {
                    target.hp -= dt * 30; // 30 DPS
                    if (target.hp <= 0) {
                        state.plants = state.plants.filter(x => x !== target);
                    }
                } else {
                    z.x -= dt * 5; // Move
                }
            });

            // 3. PROJECTILES
            for (let i = state.projectiles.length - 1; i >= 0; i--) {
                const p = state.projectiles[i];
                p.x += p.vx * dt;

                // Hit?
                const hitZ = state.zombies.find(z => Math.abs(z.x - p.x) < 2 && Math.abs(z.z - p.z) < 1);
                if (hitZ) {
                    hitZ.hp -= 25;
                    state.projectiles.splice(i, 1);
                    if (hitZ.hp <= 0) {
                        state.zombies = state.zombies.filter(x => x !== hitZ);
                        state.score += 10;
                    }
                    continue;
                }

                if (p.x > 100) state.projectiles.splice(i, 1); // Despawn
            }

            // Sync physics/logic
            state.suns.forEach(s => { if (s.y > 2) s.y -= dt * 10; });

            // Broadcast every frame? Or interval? Frame for smoothness for now
            broadcastState();

            renderState();
            renderer.render(scene, camera);
        }

        function renderLoop() {
            requestAnimationFrame(renderLoop);
            renderState();
            renderer.render(scene, camera);
        }

        // Reconcile Visuals
        const matPlants = {
            'peashooter': new THREE.MeshStandardMaterial({ color: 0x00FF00 }),
            'sunflower': new THREE.MeshStandardMaterial({ color: 0xFFD700 }),
            'wallnut': new THREE.MeshStandardMaterial({ color: 0x8D6E63 })
        };
        const matProjectile = new THREE.MeshStandardMaterial({ color: 0x00FFFF });
        const matZombie = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
        const matSun = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });

        function renderState() {
            const usedIds = new Set();

            // Helper
            const sync = (list, type) => {
                list.forEach(ent => {
                    usedIds.add(ent.id);
                    let mesh = objects.meshMap.get(ent.id);
                    if (!mesh) {
                        // Create
                        if (type === 'plant') {
                            mesh = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 6), matPlants[ent.type]);
                        } else if (type === 'zombie') {
                            mesh = new THREE.Mesh(new THREE.BoxGeometry(3, 8, 3), matZombie);
                        } else if (type === 'sun') {
                            mesh = new THREE.Mesh(new THREE.SphereGeometry(2), matSun);
                            mesh.userData.type = 'SUN';
                            mesh.userData.id = ent.id;
                        } else if (type === 'projectile') {
                            mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5), matProjectile);
                        }
                        scene.add(mesh);
                        objects.meshMap.set(ent.id, mesh);
                    }

                    // Update
                    if (type === 'plant') {
                        const px = (ent.gx - CONFIG.GRID_W / 2 + 0.5) * CONFIG.TILE_SIZE;
                        const pz = (ent.gz - CONFIG.GRID_H / 2 + 0.5) * CONFIG.TILE_SIZE;
                        mesh.position.set(px, 3, pz);
                    } else if (type === 'zombie') {
                        mesh.position.set(ent.x, 4, ent.z);
                    } else if (type === 'sun') {
                        mesh.position.set(ent.x, ent.y, ent.z);
                    } else if (type === 'projectile') {
                        mesh.position.set(ent.x, 3, ent.z);
                    }
                });
            };

            sync(state.plants, 'plant');
            sync(state.zombies, 'zombie');
            sync(state.suns, 'sun');
            sync(state.projectiles, 'projectile');

            // Cleanup
            for (const [id, mesh] of objects.meshMap) {
                if (!usedIds.has(id)) {
                    scene.remove(mesh);
                    objects.meshMap.delete(id);
                }
            }
        }

    </script>
</body>

</html>